# UX 인터랙션 패턴 가이드

<!-- affects: frontend -->
<!-- requires-update: 04_frontend/design-system.md -->

## 이 문서가 답하는 질문

- Canvas의 공통 UX 인터랙션 패턴은 무엇인가?
- 사용자에게 피드백을 언제, 어떻게 제공하는가?
- 모달/시트/페이지 전환의 기준은 무엇인가?
- 프로세스 디자이너의 캔버스 인터랙션은 어떻게 설계되는가?

---

## 1. 사용자 흐름 공통 패턴 (Common User Flow Patterns)

Canvas 전체에서 반복되는 인터랙션 흐름을 표준화한다. 표준 패턴을 정의하는 이유는 (1) 사용자의 학습 비용을 줄이고, (2) 개발자 간 구현 일관성을 보장하며, (3) QA 검증 범위를 명확히 하기 위함이다.

### 1.1 목록 -> 상세 -> 편집 -> 저장 흐름 (CRUD Flow)

```
[목록 페이지]          [상세 페이지]          [편집 모드]
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  항목 리스트   │───▶│  항목 상세    │───▶│  인라인 편집   │
│  (DataTable)  │    │  (읽기 전용)  │    │  또는 폼      │
│               │    │               │    │               │
│  행 클릭      │    │  [편집] 클릭  │    │  [저장] 클릭  │
│  또는 링크    │    │               │    │  또는 Ctrl+S  │
└──────────────┘    └──────────────┘    └──────────────┘
                                              │
                                              ▼
                                        [서버 저장]
                                        성공: 토스트 + 상세로 복귀
                                        실패: 인라인 에러 표시
```

| 적용 대상 | 목록 | 상세 | 편집 |
|-----------|------|------|------|
| 케이스 | CaseListPage | CaseDetailPage | CaseDetailPage 인라인 |
| 문서 | DocumentListPage | DocumentEditorPage | DocumentEditorPage (Monaco) |
| 데이터소스 | DatasourcePage 카드 목록 | 카드 펼침 | ConnectionForm (Dialog) |
| 알림 규칙 | WatchDashboardPage | AlertCard | AlertRuleEditor (Sheet) |
| 프로세스 보드 | ProcessDesignerListPage | ProcessDesignerPage | 캔버스 직접 편집 |

**왜 이 패턴인가?**: 목록 -> 상세 -> 편집의 3단계 흐름은 사용자가 "탐색 -> 확인 -> 행동"의 인지적 단계를 자연스럽게 따라가도록 한다. 바로 편집 모드로 진입하면 실수로 데이터를 변경할 위험이 있다.

### 1.2 검색 -> 필터 -> 정렬 -> 페이지네이션 흐름

```
┌─── 데이터 탐색 UI 패턴 ──────────────────────────────────────────┐
│                                                                    │
│  [검색 바]                                                         │
│  ┌─────────────────────────────────────────────┐                  │
│  │ 🔍 검색어 입력... (디바운스 300ms)           │                  │
│  └─────────────────────────────────────────────┘                  │
│                                                                    │
│  [필터 바]                                                         │
│  [전체 상태 ▼] [전체 유형 ▼] [날짜 범위] [초기화]                 │
│                                                                    │
│  [테이블]                                                          │
│  ┌────┬────────────┬──────┬────────┐                              │
│  │ #  │ 이름 ▲ ▼   │ 상태 │ 날짜   │  ← 컬럼 헤더 클릭: 정렬     │
│  ├────┼────────────┼──────┼────────┤                              │
│  │ .. │ ...        │ ...  │ ...    │                              │
│  └────┴────────────┴──────┴────────┘                              │
│                                                                    │
│  ◀ 1 2 3 ... 8 ▶                            20건/페이지 ▼        │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

**상태 보존 규칙**:

| 항목 | 저장 위치 | 이유 |
|------|-----------|------|
| 검색어 | URL search params (`?search=`) | 북마크/공유 가능해야 함 |
| 필터 값 | URL search params (`?status=&type=`) | 동일 |
| 정렬 | URL search params (`?sort=name&order=asc`) | 동일 |
| 페이지 번호 | URL search params (`?page=2`) | 뒤로 가기 시 복원 필수 |
| 페이지 크기 | URL search params (`?pageSize=20`) | 사용자 선호 유지 |
| 스크롤 위치 | 브라우저 기본 동작 | React Router ScrollRestoration 활용 |

**왜 URL에 저장하는가?**: K-AIR에서 필터를 컴포넌트 로컬 state에 저장했을 때, 상세 페이지에서 목록으로 돌아오면 필터가 초기화되는 문제가 반복 발생했다. URL 동기화로 이 문제를 근본적으로 해결한다.

### 1.3 AI 생성 -> 인간 검토 -> 승인 (HITL) 흐름

```
[AI 생성 요청]    [AI 초안 표시]    [인간 검토]     [승인/반려]
┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐
│ "AI 생성    │  │  AI 응답    │  │ 인라인      │  │ [승인]     │
│  요청" 클릭 │─▶│  스트리밍   │─▶│ 코멘트 +   │─▶│ [수정 요청]│
│             │  │  표시       │  │ Diff 표시   │  │ [반려]     │
│ 로딩 피드백 │  │  (SSE)     │  │             │  │            │
└────────────┘  └────────────┘  └────────────┘  └────────────┘
     │                │                │                │
     ▼                ▼                ▼                ▼
  스피너 +         스트리밍          편집기 +          확인 다이얼로그
  "생성 중..."     토큰 표시        리뷰 패널         (되돌릴 수 없음 경고)
```

**HITL이 적용되는 영역**:

| 영역 | AI 생성물 | 인간 검토 포인트 | 근거 |
|------|-----------|-----------------|------|
| 문서 관리 | AI 초안 문서 | 인라인 코멘트 + Diff + 승인 | 업무 문서의 정확성은 AI가 보장할 수 없음 |
| NL2SQL | AI 생성 SQL | SQL 미리보기 + 수정 버튼 | 잘못된 SQL은 데이터 오류 유발 |
| 프로세스 디자이너 | AI 역공학 프로세스 모델 | 자동 생성 노드 수동 보완 | 이벤트 로그만으로 비즈니스 맥락 완전 파악 불가 |

**왜 HITL인가?**: AI가 "80% 정확한" 결과를 빠르게 생성하고, 인간이 나머지 20%를 검증하는 것이 가장 효율적인 협업 모델이다. 100% AI 자동화는 현재 기술 수준에서 비즈니스 문서/분석 영역에 적합하지 않다.

### 1.4 실시간 협업 흐름 (프로세스 디자이너 Yjs 패턴)

```
[사용자 A]                    [Yjs CRDT]                   [사용자 B]
    │                             │                             │
    │  노드 이동                  │                             │
    │  ───────────────────▶      │                             │
    │                        Y.Map 업데이트                     │
    │                        (positions)                        │
    │                             │  ────────────────────▶      │
    │                             │     위치 변경 수신          │
    │                             │     캔버스 리렌더           │
    │                             │                             │
    │                             │     커서 위치 업데이트       │
    │                             │  ◀────────────────────     │
    │  ◀──────────────────       │                             │
    │  커서 표시 업데이트         │                             │
```

**협업 UX 규칙**:

| 규칙 | 동작 | 근거 |
|------|------|------|
| 다른 사용자가 선택한 노드 표시 | 해당 사용자의 고유 색상 테두리 | 편집 충돌 회피를 위한 시각적 힌트 |
| 동시 편집 중인 노드 경고 | 노드에 "편집 중: 김분석가" 표시 | 같은 노드 동시 수정 방지 |
| 네트워크 끊김 시 | 배너 표시: "오프라인 모드 - 재연결 시 자동 동기화" | 사용자 불안 해소 |
| 재연결 성공 시 | 토스트: "연결 복원됨. 변경사항이 동기화되었습니다." | 확인 피드백 |

---

## 2. 피드백 체계 (Feedback System)

사용자에게 시스템 상태를 투명하게 전달하는 것은 신뢰 구축의 핵심이다. 모든 사용자 행동에는 반드시 피드백이 동반되어야 한다.

### 2.1 성공/실패/경고/정보 피드백 규칙

| 유형 | 색상 (CSS 변수) | 아이콘 | 용도 | 표시 방식 |
|------|-----------------|--------|------|-----------|
| 성공 (success) | `--success` 초록 | CheckCircle | 작업 완료 | 토스트 (3초 자동 닫힘) |
| 에러 (error) | `--destructive` 빨강 | XCircle | 작업 실패 | 토스트 (수동 닫힘) 또는 인라인 |
| 경고 (warning) | `--warning` 주황 | AlertTriangle | 주의 필요 | 토스트 (5초) 또는 배너 |
| 정보 (info) | `--info` 파랑 | Info | 안내 사항 | 토스트 (3초 자동 닫힘) |

**왜 에러 토스트만 수동 닫힘인가?**: 사용자가 에러 메시지를 읽고 대응 방법을 파악할 시간이 필요하다. 성공 토스트는 확인만 하면 되므로 자동으로 사라져도 무방하다.

### 2.2 Toast 사용 가이드

```typescript
// 올바른 토스트 사용 예시

// 성공: 간결한 완료 메시지
toast.success('문서가 승인되었습니다.');
toast.success('케이스가 생성되었습니다.');
toast.success('시나리오가 저장되었습니다.');

// 에러: 무엇이 실패했는지 + 어떻게 해결하는지
toast.error('문서 저장에 실패했습니다. 네트워크 연결을 확인해 주세요.');
toast.error('데이터소스 연결 실패: Connection refused. 호스트 주소를 확인해 주세요.');

// 경고: 주의가 필요한 상황
toast.warning('기한이 1일 남았습니다.');
toast.warning('동시 편집자가 있습니다. 충돌에 주의하세요.');

// 정보: 시스템 안내
toast.info('새로운 알림이 3건 있습니다.');
toast.info('메타데이터 동기화가 완료되었습니다.');
```

**Toast 위치**: 화면 우측 상단 (top-right). 여러 토스트가 쌓일 때 아래로 적층된다.

**Toast 금지 사항**:
- 폼 유효성 검증 에러를 토스트로 표시하지 않음 (인라인 에러 사용)
- 로딩 상태를 토스트로 표시하지 않음 (스피너/스켈레톤 사용)
- 같은 메시지를 중복 표시하지 않음 (동일 키의 토스트는 업데이트)

### 2.3 실시간 알림(Watch Alert) 토스트 규칙

WebSocket으로 수신되는 Watch 알림은 심각도에 따라 토스트 표시 여부와 닫힘 방식이 달라진다. 이 규칙은 사용자 작업 흐름 방해를 최소화하면서도 긴급한 알림을 놓치지 않도록 균형을 맞춘다.

| 심각도 | 토스트 호출 | 닫힘 방식 | 벨 카운터 | 근거 |
|--------|-----------|----------|----------|------|
| **CRITICAL** | `toast.error(message)` | 수동 닫힘 | +1 | 즉각 인지 필요, 자동 사라짐 위험 |
| **HIGH** | `toast.warning(message)` | 수동 닫힘 | +1 | 주의 필요, 놓치면 안 됨 |
| **MEDIUM** | `toast.warning(message)` | 5초 자동 닫힘 | +1 | 참고 수준, 장시간 방해 불필요 |
| **LOW / INFO** | 토스트 없음 | - | +1 | 벨 카운터만 증가 — 노이즈 최소화 |

**왜 LOW/INFO는 토스트를 표시하지 않는가?**: 새 케이스 등록, 동기화 완료 등 정보성 알림이 잦으면 사용자가 토스트 자체를 무시하는 "알림 피로(alert fatigue)"가 발생한다. 정보성 알림은 벨 카운터로만 알리고, 사용자가 필요할 때 드롭다운이나 Watch 대시보드에서 확인한다.

> 상세 구현은 `watch-alerts.md` §9.4, Watch 알림 벨 드롭다운 UI는 `watch-alerts.md` §7을 참조한다.

### 2.4 인라인 에러 vs 토스트 에러 vs 전역 에러 바운더리 사용 기준

```
에러 발생
├── 사용자 입력 관련 에러인가?
│   └── YES → 인라인 에러 (필드 하단에 빨간 텍스트)
│       예: "이메일 형식이 올바르지 않습니다"
│       예: "비밀번호는 8자 이상이어야 합니다"
│
├── 특정 API 호출 실패인가?
│   └── YES → 토스트 에러 (수동 닫힘)
│       예: "문서 저장 실패: 서버 오류"
│       예: "데이터소스 연결 실패"
│
├── 인증 만료인가?
│   └── YES → 자동 토큰 갱신 시도 → 실패 시 로그인 리다이렉트
│       (사용자에게 에러 표시하지 않음, 자동 처리)
│
└── 예상치 못한 런타임 에러인가?
    └── YES → 전역 에러 바운더리 (ErrorPage)
        예: "예기치 않은 오류가 발생했습니다. [새로고침] [대시보드로 이동]"
```

**왜 3단계로 나누는가?**: 에러의 심각도와 사용자의 조치 가능성에 따라 표시 방식이 달라야 한다. 입력 에러는 즉시 수정 가능하므로 인라인이 적합하고, 서버 에러는 재시도 외에 선택지가 없으므로 토스트가 적합하며, 치명적 에러는 페이지 전체를 대체해야 한다.

### 2.4 로딩 피드백: 스켈레톤 vs 스피너 vs 프로그레스 바 사용 기준

| 피드백 유형 | 사용 시점 | 예시 | 근거 |
|------------|----------|------|------|
| **스켈레톤 (Skeleton)** | 초기 페이지 로딩, 콘텐츠 영역 대체 | 케이스 목록, 대시보드 카드, 문서 목록 | 레이아웃 미리보기로 CLS(Cumulative Layout Shift) 방지 |
| **스피너 (Spinner)** | 버튼 클릭 후 응답 대기, 짧은 비동기 작업 | 저장 버튼, 승인 버튼, 연결 테스트 | 사용자가 행동한 지점에서 즉각적인 피드백 |
| **프로그레스 바 (Progress Bar)** | 진행률을 알 수 있는 장기 작업 | 메타데이터 동기화 (SSE), 파일 업로드 | 완료 시점 예측 가능 -> 사용자 이탈 방지 |
| **스트리밍 표시 (Streaming)** | AI 응답, SSE 데이터 | NL2SQL 생각 과정, AI 문서 생성 | AI가 "작동 중"임을 체감시키는 신뢰 구축 |

```
스켈레톤 사용 기준:
├── 페이지 최초 렌더링 시 → LoadingSkeleton (Suspense fallback)
├── 테이블 데이터 로딩 시 → 테이블 형태의 스켈레톤 (행 3~5개)
├── 카드 레이아웃 로딩 시 → 카드 형태의 스켈레톤
└── 차트 데이터 로딩 시 → 차트 영역 크기의 직사각형 스켈레톤

스피너 사용 기준:
├── 버튼 내부 (isLoading prop) → 버튼 텍스트를 스피너로 대체
├── 소형 컴포넌트 갱신 → 해당 영역에 오버레이 스피너
└── 모달 내 작업 → 모달 내부 스피너

프로그레스 바 사용 기준:
├── 메타데이터 동기화 (SSE progress 이벤트)
├── 파일 업로드/다운로드
└── 배치 처리 진행 상황
```

### 2.5 빈 상태(Empty State) 디자인 가이드

모든 목록/테이블/피드에는 데이터가 없을 때의 빈 상태 디자인이 필수이다.

```
┌──────────────────────────────────────┐
│                                      │
│            [아이콘]                  │
│         (회색, 48px)                │
│                                      │
│      데이터가 없습니다.              │
│   (text-muted-foreground, text-sm)  │
│                                      │
│        [CTA 버튼]                   │
│   "첫 번째 OOO 만들기"              │
│                                      │
└──────────────────────────────────────┘
```

| 화면 | 아이콘 | 메시지 | CTA |
|------|--------|--------|-----|
| 케이스 목록 | FileText | 등록된 케이스가 없습니다. | + 새 케이스 |
| 문서 목록 | FileSearch | 이 케이스에 문서가 없습니다. | + 새 문서 / AI 생성 요청 |
| 검색 결과 없음 | SearchX | 검색 결과가 없습니다. 검색어를 변경해 보세요. | 필터 초기화 |
| 알림 피드 | Bell | 새로운 알림이 없습니다. | (CTA 없음) |
| NL2SQL 대화 | MessageSquare | 자연어로 데이터를 질문해 보세요. | 예시 질문 3개 표시 |
| 프로세스 보드 | Layout | 프로세스 보드가 없습니다. | + 새 보드 / AI 프로세스 발견 |
| 필터 결과 없음 | Filter | 조건에 맞는 항목이 없습니다. | 필터 초기화 |

**왜 빈 상태가 중요한가?**: 빈 상태는 사용자가 시스템을 처음 접하는 순간이다. 이 순간에 "무엇을 해야 하는지" 명확한 안내(CTA)를 제공하면 온보딩 이탈률을 크게 낮출 수 있다.

---

## 3. 모달/다이얼로그 사용 기준 (Modal Usage Guidelines)

### 3.1 선택 기준 의사결정 트리

```
사용자 작업이 발생했다
│
├── 작업이 현재 컨텍스트를 완전히 벗어나는가?
│   └── YES → 전체 페이지 전환 (새 라우트)
│       예: 케이스 상세 보기, 문서 편집기, 프로세스 디자이너
│
├── 작업이 5개 이상의 필드 입력을 요구하는가?
│   └── YES → Sheet (슬라이드 패널, 우측에서)
│       예: 알림 규칙 편집, 데이터소스 연결 폼, 노드 속성 편집
│
├── 작업이 간단한 확인/취소인가?
│   └── YES → Dialog (중앙 모달)
│       예: 삭제 확인, 승인 확인, 반려 사유 입력
│
└── 작업이 1~2개 필드의 빠른 입력인가?
    └── YES → 인라인 편집 또는 Popover
        예: 노드 이름 더블클릭 편집, 상태 변경 드롭다운
```

### 3.2 확인 필요 작업 (파괴적/중요 작업)

| 작업 | UI 패턴 | 확인 메시지 | 확인 버튼 |
|------|---------|------------|-----------|
| 항목 삭제 | AlertDialog | "이 {항목}을(를) 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다." | "삭제" (destructive 변형) |
| 문서 승인 | Dialog | "이 문서를 최종 승인하시겠습니까?" | "승인" (primary) |
| 문서 반려 | Dialog + Textarea | "반려 사유를 입력해 주세요." | "반려" (destructive) |
| 로그아웃 | AlertDialog | "로그아웃하시겠습니까?" | "로그아웃" |
| 필터 초기화 | 확인 없음 | (즉시 실행) | - |
| 시나리오 저장 | 확인 없음 | (즉시 실행 + 성공 토스트) | - |

**왜 삭제만 AlertDialog인가?**: AlertDialog는 Escape 키와 배경 클릭으로 닫히지 않는다. 되돌릴 수 없는 파괴적 작업에만 사용하여 실수를 방지한다. 일반 Dialog는 Escape로 닫을 수 있다.

### 3.3 Sheet(슬라이드 패널) vs Dialog 사용 시점

| 기준 | Sheet (우측 패널) | Dialog (중앙 모달) |
|------|------------------|-------------------|
| **필드 수** | 5개 이상 | 4개 이하 |
| **콘텐츠 참조** | 뒤 화면 참조 필요 | 뒤 화면 참조 불필요 |
| **작업 복잡도** | 탐색/선택이 포함된 복합 작업 | 단순 확인/입력 |
| **화면 차지** | 우측 1/3 ~ 1/2 | 중앙 고정 너비 |
| **적용 예시** | 알림 규칙 편집, NL2SQL 히스토리, 노드 속성 패널 | 삭제 확인, 승인, 간단 폼 |

---

## 4. 네비게이션 & 정보 계층 (Navigation & Information Architecture)

### 4.1 Breadcrumb 표시 규칙

```
케이스 중첩 라우트 Breadcrumb:
대시보드 > 케이스 > 물류최적화 프로젝트 > 문서 > 이해관계자 목록 v3

분석 라우트 Breadcrumb:
분석 > OLAP 피벗

데이터 라우트 Breadcrumb:
데이터 > 온톨로지

프로세스 디자이너 Breadcrumb:
프로세스 > 물류관리 보드
```

| 규칙 | 설명 | 근거 |
|------|------|------|
| 현재 위치는 텍스트로만 표시 | 마지막 항목은 링크가 아님 | 클릭해도 같은 페이지이므로 혼란 방지 |
| 중간 경로는 클릭 가능한 링크 | 상위 페이지로 직접 이동 가능 | 다단계 네비게이션 효율화 |
| 3단계 이상은 말줄임 처리 | "... > 물류최적화 > 문서 > 이해관계자 목록" | 모바일/좁은 화면 대응 |
| 케이스 ID가 아닌 이름 표시 | "물류최적화 프로젝트" (not "2024-PRJ-100123") | 사용자 인지 가능한 레이블 |

### 4.2 사이드바 네비게이션 활성 상태 규칙

```
사이드바 활성 상태:
├── 정확히 일치하는 라우트: 해당 메뉴 활성 (배경 하이라이트)
├── 하위 라우트: 상위 메뉴 활성
│   예: /cases/123/documents → "케이스" 메뉴 활성
├── 그룹 내 하위 항목: 그룹 펼침 + 해당 항목 활성
│   예: /analysis/olap → "분석" 그룹 펼침 + "OLAP 피벗" 활성
└── 해당 없는 라우트: 아무것도 활성화하지 않음
```

**활성 상태 시각 처리**:
- 활성 메뉴: `bg-sidebar-accent text-sidebar-foreground font-medium`
- 비활성 메뉴: `text-sidebar-foreground/70 hover:bg-sidebar-accent/50`
- 그룹 펼침 상태: ChevronDown 아이콘 회전

### 4.3 페이지 제목 계층 (H1, H2, H3 사용 기준)

| 요소 | Tailwind 클래스 | 용도 | 페이지당 허용 수 |
|------|----------------|------|-----------------|
| H1 | `text-2xl font-bold` | 페이지 제목 | 정확히 1개 |
| H2 | `text-xl font-semibold` | 섹션 제목 | 복수 허용 |
| H3 | `text-lg font-medium` | 하위 섹션/카드 제목 | 복수 허용 |
| H4 이하 | 사용 자제 | - | - |

**왜 H4 이하를 자제하는가?**: 정보 계층이 4단계 이상이면 페이지 구조 자체를 재설계해야 한다. 그것은 하나의 페이지에 너무 많은 정보를 담고 있다는 신호이다.

### 4.4 컨텍스트 전환 시 데이터 보존 규칙

| 전환 유형 | 보존 대상 | 보존 방법 | 근거 |
|-----------|----------|-----------|------|
| 목록 -> 상세 -> 목록 복귀 | 필터, 정렬, 페이지, 스크롤 | URL search params + ScrollRestoration | 탐색 후 복귀 시 원래 위치 유지 |
| 탭 전환 (같은 페이지 내) | 각 탭의 입력 상태 | 탭 컨텐츠를 숨기되 DOM에 유지 (display:none) | 탭 전환 시 입력 내용 소실 방지 |
| 페이지 이동 (다른 Feature) | 보존하지 않음 | - | 다른 Feature 컨텍스트에서 이전 상태는 무의미 |
| 브라우저 새로고침 | 인증, 테마, 사이드바 | sessionStorage + persist 미들웨어 | 사용자 세션 유지 |

**예외**: 프로세스 디자이너 캔버스 데이터는 Yjs + IndexedDB로 오프라인에서도 보존된다. 이는 다른 Feature와 달리 장시간 편집 작업이 발생하기 때문이다.

---

## 5. 입력 패턴 (Input Patterns)

### 5.1 폼 레이아웃 규칙

| 기준 | 단일 컬럼 | 다중 컬럼 (2열) |
|------|-----------|----------------|
| 필드 수 | 1~8개 | 9개 이상 |
| 필드 관계 | 순차적 입력 | 관련 필드끼리 그룹화 가능 |
| 화면 너비 | 모바일/태블릿 | 데스크톱 (1024px 이상) |
| 적용 예시 | 데이터소스 연결 폼, 로그인 | 케이스 상세 편집 (좌: 기본 정보, 우: 할당/일정) |

**왜 기본은 단일 컬럼인가?**: 연구 결과에 따르면 단일 컬럼 폼이 다중 컬럼보다 완료율이 높다. 사용자의 시선 이동이 수직으로 단순해지기 때문이다. 다중 컬럼은 필드 수가 많아 스크롤이 과도할 때만 사용한다.

### 5.2 필수/선택 필드 표시 규칙

```
필수 필드:
데이터소스 이름 *
[                              ]

선택 필드:
스키마 (선택)
[public                        ]

또는 대부분이 필수인 경우:
스키마 (선택사항)
[public                        ]
```

| 규칙 | 설명 |
|------|------|
| 필수 필드는 라벨 뒤에 `*` 표시 (빨간색) | `<span className="text-destructive">*</span>` |
| 선택 필드가 소수일 때 "(선택)" 접미사 추가 | 대부분 필수인 폼에서 사용 |
| 필수 필드가 소수일 때만 `*` 사용 | 대부분 선택인 폼에서는 오히려 "필수" 표시 |
| 제출 시 빈 필수 필드에 인라인 에러 | "이 필드는 필수입니다" |

### 5.3 실시간 유효성 검증 vs 제출 시 검증 기준

| 검증 시점 | 적용 대상 | 동작 | 근거 |
|-----------|----------|------|------|
| **입력 중 (onChange)** | 이메일 형식, 비밀번호 강도 | 입력할 때마다 검증 표시 | 즉각적인 가이드가 도움됨 |
| **포커스 아웃 (onBlur)** | 대부분의 텍스트 필드 | 필드를 벗어날 때 검증 | 입력 중 간섭 최소화 |
| **제출 시 (onSubmit)** | 서버 중복 검사, 연결 테스트 | 전체 폼 제출 시 검증 | 서버 호출이 필요한 검증 |

```
추천 조합 (React Hook Form):
- mode: 'onBlur'        (기본: 포커스 아웃 시 검증)
- reValidateMode: 'onChange'  (에러 표시 후: 입력 시마다 재검증)
```

**왜 onBlur 기본인가?**: onChange로 하면 사용자가 아직 입력 중인데 에러를 표시하여 불쾌한 경험을 줄 수 있다. onBlur는 사용자가 "입력을 완료했다"는 의도를 존중한다.

### 5.4 자동 저장 vs 수동 저장 기준

| Feature | 저장 방식 | 저장 주체 | 근거 |
|---------|----------|----------|------|
| 프로세스 디자이너 | 자동 저장 (Yjs CRDT) | Yjs -> WebSocket -> 서버 | 실시간 협업에서 저장 버튼은 개념적으로 맞지 않음 |
| 문서 편집기 | 수동 저장 (저장 버튼 + Ctrl+S) | 사용자 명시적 행동 | 버전 관리 필요, 의도하지 않은 변경 방지 |
| What-if 슬라이더 | 로컬만 변경 -> "분석 실행"으로 서버 호출 | 사용자 명시적 행동 | 매 슬라이더 변경마다 API 호출은 비용 과다 |
| 알림 규칙 편집 | 수동 저장 (저장 버튼) | 사용자 명시적 행동 | 규칙 변경은 즉시 영향을 미치므로 의도적 행동 필요 |
| OLAP 피벗 설정 | URL 동기화 (자동) + 쿼리 실행은 수동 | 하이브리드 | 설정은 보존하되, 비용이 큰 쿼리는 명시적 실행 |
| 필터/검색 | URL 자동 동기화 | 자동 (디바운스 300ms) | 탐색 행위는 즉시 반영이 자연스러움 |

**의사결정 기준**:
1. 실시간 협업이 필요한가? -> 자동 저장 (Yjs)
2. 서버 비용이 높은 작업인가? -> 수동 실행
3. 변경이 즉시 다른 사용자에게 영향을 미치는가? -> 수동 저장
4. 탐색/필터링 행위인가? -> 자동 (URL)

---

## 6. 데이터 시각화 가이드라인 (Data Visualization Guidelines)

### 6.1 차트 타입 선택 기준

| 데이터 특성 | 차트 타입 | 라이브러리 | 적용 예시 |
|------------|----------|-----------|----------|
| 항목 간 크기 비교 | Bar (세로/가로) | Recharts BarChart | OLAP 결과, 케이스 통계 |
| 시간 흐름 추이 | Line | Recharts LineChart | 트렌드 분석, KPI 추이 |
| 구성비 (합계=100%) | Pie / Donut | Recharts PieChart | 케이스 유형별 분포 |
| 민감도 분석 (양방향) | Tornado (가로 Bar) | Recharts BarChart (커스텀) | What-if 시나리오 |
| 관계 네트워크 | Force-directed Graph | react-force-graph-2d | 온톨로지 브라우저 |
| 프로세스 흐름 | Canvas (Konva) | react-konva | 프로세스 디자이너 |
| 범용 (기본) | Table | TanStack Table + Shadcn | 대부분의 데이터 표시 |

**차트 선택 의사결정**:
```
표현할 데이터가 있다
├── 비교하고 싶은가? → Bar Chart
├── 추이를 보고 싶은가? → Line Chart
├── 비율을 보고 싶은가? → Pie Chart (항목 6개 이하)
├── 관계를 보고 싶은가? → Force Graph
├── 영향도를 보고 싶은가? → Tornado Chart
└── 확실하지 않다? → Table (가장 안전한 기본값)
```

### 6.2 색상 사용 규칙

**상태 색상 (시맨틱)** -- 의미가 고정된 색상:

| 의미 | 라이트 모드 | 다크 모드 | 용도 |
|------|-----------|----------|------|
| 성공/정상 | `--success` 초록 | 어두운 초록 | SLA 이내, 승인됨, 연결됨 |
| 위험/에러 | `--destructive` 빨강 | 어두운 빨강 | SLA 위반, 반려, 오류 |
| 경고 | `--warning` 주황 | 어두운 주황 | SLA 근접, 기한 임박 |
| 정보 | `--info` 파랑 | 밝은 파랑 | 안내, 기본 상태 |
| 비활성 | `--muted` 회색 | 어두운 회색 | 초안, 닫힘, 아카이브 |

**차트 색상 (데이터 구분용)** -- 순서대로 사용:

```css
--chart-1: hsl(221, 83%, 53%);   /* 파랑 (Primary) */
--chart-2: hsl(142, 76%, 36%);   /* 초록 */
--chart-3: hsl(38, 92%, 50%);    /* 주황 */
--chart-4: hsl(280, 65%, 60%);   /* 보라 */
--chart-5: hsl(0, 84%, 60%);     /* 빨강 */
```

**계층 색상 (온톨로지 전용)**:

| 계층 | 색상 | Hex |
|------|------|-----|
| KPI | 빨강 | `#EF4444` |
| Measure | 주황 | `#F59E0B` |
| Process | 파랑 | `#3B82F6` |
| Resource | 초록 | `#10B981` |

**색상 금지 사항**: 색상만으로 정보를 전달하지 않는다. 반드시 아이콘, 텍스트, 패턴(점선/실선) 등 보조 수단을 병행한다. 이유: 색각 이상 사용자 접근성 보장.

### 6.3 테이블 vs 카드 vs 그래프 표현 기준

| 기준 | 테이블 (DataTable) | 카드 (Card Grid) | 그래프 (Chart/Graph) |
|------|-------------------|-----------------|---------------------|
| 데이터 특성 | 구조화된 다중 속성 | 핵심 정보 + 시각 요소 | 패턴/추이/관계 |
| 항목 수 | 10~수천 건 | 1~20건 | 제한 없음 |
| 비교 필요 | 항목 간 속성 비교 | 개별 항목 요약 | 전체 분포/추이 |
| 적용 예시 | 케이스 목록, OLAP 결과, 문서 목록 | 데이터소스 카드, 통계 카드, 알림 카드 | 온톨로지, 프로세스, 차트 |

### 6.4 드래그앤드롭 인터랙션 패턴 (@dnd-kit)

Canvas에서 드래그앤드롭이 사용되는 영역:

| 영역 | 라이브러리 | 드래그 대상 | 드롭 대상 |
|------|-----------|-----------|----------|
| OLAP 피벗 빌더 | @dnd-kit | 차원/측정값 칩 | 행/열/측정/필터 영역 |
| 프로세스 디자이너 | react-konva 내장 | 툴박스 노드 아이콘 | 캔버스 영역 |

**접근성 요건 (@dnd-kit)**:

| 요건 | 구현 방법 | 근거 |
|------|----------|------|
| 키보드 DnD | Space로 들기, 방향키로 이동, Space로 놓기 | 마우스 사용 불가 사용자 |
| 스크린 리더 안내 | `aria-describedby`로 조작 방법 안내 | 시각 장애 사용자 |
| 포커스 표시 | 드래그 대상에 명확한 포커스 링 | 키보드 탐색 시 위치 파악 |
| 취소 지원 | Escape로 드래그 취소 | 실수 방지 |

---

## 7. 프로세스 디자이너 UX 가이드라인 (Process Designer UX)

프로세스 디자이너는 Canvas에서 가장 복잡한 인터랙션을 가진 Feature이다. react-konva 기반 캔버스 + Yjs 실시간 협업 + 프로세스 마이닝 오버레이가 결합되어 있으므로 별도의 UX 가이드라인이 필요하다.

### 7.1 캔버스 인터랙션 패턴

**선택 (Select)**:
```
단일 선택:  노드 클릭 → 속성 패널에 선택된 노드 표시
다중 선택:  Shift+클릭 또는 영역 드래그 → 복수 노드 선택
전체 선택:  Ctrl+A → 모든 노드 선택
선택 해제:  캔버스 빈 영역 클릭 → 선택 해제
```

**이동 (Move)**:
```
단일 이동:  노드 드래그 → Yjs positions 맵 업데이트
다중 이동:  선택된 복수 노드 드래그 → 상대 위치 유지하며 이동
정밀 이동:  방향키 → 1px 이동, Shift+방향키 → 10px 이동
```

**연결 (Connect)**:
```
연결 생성:  C키 또는 도구 선택 → 소스 노드 클릭 → 타겟 노드 클릭
연결 삭제:  연결선 클릭 → Delete 키
연결 유형:  소스/타겟 노드 타입에 따라 자동 결정
            (예: Action → Event = triggers)
```

**줌/패닝 (Zoom/Pan)**:
```
줌 인:     Ctrl+스크롤 업 또는 Ctrl+=
줌 아웃:   Ctrl+스크롤 다운 또는 Ctrl+-
패닝:      Space+드래그 또는 마우스 중간 버튼 드래그
줌 리셋:   Ctrl+0 → 전체 보기 (Fit to Screen)
줌 범위:   25% ~ 400% (이 범위를 벗어나면 UX가 불안정)
```

### 7.2 실시간 협업 UX 규칙

| 상황 | UX 처리 | 근거 |
|------|---------|------|
| 다른 사용자 커서 표시 | 이름 태그 + 고유 색상 화살표 (반투명) | 위치 인식 |
| 다른 사용자가 선택한 노드 | 해당 사용자 색상 테두리 (2px 점선) | 암묵적 잠금 힌트 |
| 같은 노드 동시 편집 시도 | "김분석가가 편집 중입니다" 툴팁 + 편집 불가 | 충돌 예방 (소프트 잠금) |
| 사용자 입장/퇴장 | 헤더 아바타 목록 업데이트 + 미세 애니메이션 | 협업 인식 |
| 연결 끊김 | 캔버스 상단 배너: "오프라인 - 변경사항은 재연결 시 동기화됩니다" | 안심 |
| 연결 복원 | 배너 사라짐 + 토스트: "연결 복원됨" | 확인 |

**왜 소프트 잠금인가?**: 하드 잠금(특정 사용자만 편집 가능)은 협업 흐름을 심각하게 방해한다. Yjs CRDT가 충돌을 자동 해소하므로, 시각적 힌트로 "편집 중"을 알려주되 실제 편집을 차단하지는 않는다.

### 7.3 프로세스 마이닝 오버레이 정보 밀도 관리

프로세스 마이닝 결과를 캔버스에 오버레이하면 정보 밀도가 급격히 증가한다. 사용자가 원하는 정보 수준을 제어할 수 있어야 한다.

```
오버레이 모드 선택:
┌────────────────────────────────────────────┐
│  [오버레이 표시 ▼]                          │
│  ┌────────────────────────────────────┐    │
│  │ ○ 오버레이 없음                     │    │
│  │ ● 빈도 표시 (연결선 두께)           │    │
│  │ ○ 시간 표시 (노드에 평균 소요시간)  │    │
│  │ ○ 병목 표시 (SLA 위반 하이라이트)   │    │
│  │ ○ 이탈 경로 표시 (비정상 흐름 점선) │    │
│  │ ○ 전체 표시 (모든 정보)             │    │
│  └────────────────────────────────────┘    │
└────────────────────────────────────────────┘
```

| 오버레이 수준 | 표시 정보 | 적합한 사용 상황 |
|--------------|----------|-----------------|
| 없음 | 순수 비즈니스 프로세스 모델만 | 모델 설계/편집 중 |
| 빈도 | 연결선 두께 = 빈도 비례 | 주요 흐름 파악 |
| 시간 | 노드에 평균 소요 시간 숫자 | 처리 시간 분석 |
| 병목 | SLA 위반 노드 빨강 하이라이트 | 병목 구간 식별 |
| 이탈 경로 | 비정상 흐름 점선 표시 | 예외 경로 분석 |
| 전체 | 위 모든 정보 동시 표시 | 종합 분석 (숙련 사용자) |

**왜 단계별 제어인가?**: 모든 정보를 한 번에 표시하면 인지 과부하(cognitive overload)가 발생한다. 사용자가 분석 목적에 따라 정보 밀도를 선택할 수 있어야 한다.

### 7.4 노드 100개 이상 시 성능 체감 UX

프로세스 모델이 커지면 react-konva 렌더링 성능이 저하된다. 사용자 체감 성능을 유지하기 위한 UX 전략:

| 전략 | 동작 | 적용 임계값 | 근거 |
|------|------|-----------|------|
| **뷰포트 컬링** | 화면 밖 노드의 세부 렌더링 생략 (사각형만 표시) | 노드 50개 이상 | GPU 렌더링 부하 감소 |
| **LOD (Level of Detail)** | 줌 아웃 시 노드 라벨 숨김, 색상 사각형만 표시 | 줌 50% 미만 | 작은 텍스트 렌더링은 불필요 |
| **미니맵 활용** | 축소된 전체 뷰 + 현재 뷰포트 표시 | 항상 표시 | 대형 캔버스 탐색 지원 |
| **검색으로 탐색** | 노드 검색 -> 해당 노드로 포커스+줌 | 노드 100개 이상 시 권장 | 시각적 탐색보다 효율적 |
| **컨텍스트박스 접기** | Business Domain을 접으면 내부 노드 숨김 | 사용자 선택 | 관심 영역만 표시 |

```
성능 체감 기준:
- 60fps 유지: 노드 0~50개 (최적)
- 30fps 이상: 노드 50~200개 (수용 가능)
- 30fps 미만: 노드 200개 이상 (뷰포트 컬링 필수 적용)
```

---

## 결정 사항 (Decisions)

- **필터/검색 상태는 URL search params에 동기화한다**
  - 근거: 북마크/공유 가능성 + 뒤로 가기 복원 (K-AIR 컴포넌트 로컬 state 문제 해결)
  - 참조: 04_frontend/case-dashboard.md (필터 상태 URL 동기화)

- **에러 표시는 3단계(인라인/토스트/에러 바운더리)로 구분한다**
  - 근거: 에러 심각도와 사용자 조치 가능성에 따른 최적 피드백

- **파괴적 작업(삭제, 반려)에는 AlertDialog, 일반 확인은 Dialog 사용**
  - 근거: AlertDialog는 Escape/배경 클릭 닫힘 불가로 실수 방지

- **프로세스 디자이너 협업은 소프트 잠금(시각 힌트만)**
  - 근거: Yjs CRDT가 충돌 자동 해소, 하드 잠금은 협업 방해

- **프로세스 마이닝 오버레이는 단계별 정보 밀도 제어**
  - 근거: 인지 과부하 방지, 분석 목적별 최적 뷰 제공

- **빈 상태에 반드시 CTA(Call to Action) 포함**
  - 근거: 첫 사용자 온보딩 이탈 방지

- **자동 저장 기준: 실시간 협업 Feature만 자동, 나머지는 수동**
  - 근거: 의도하지 않은 변경 방지 vs 협업 동기화 필요성의 균형

---

## 금지됨 (Forbidden)

- 색상만으로 정보를 전달 (접근성 위반 -- 반드시 아이콘/텍스트/패턴 병행)
- 폼 유효성 에러를 토스트로 표시 (인라인 에러 사용)
- 같은 메시지의 토스트를 중복 표시 (동일 키로 업데이트)
- 필터/검색 상태를 컴포넌트 로컬 state에만 저장 (URL 동기화 필수)
- 삭제 등 파괴적 작업을 확인 없이 즉시 실행
- 로딩 상태 없이 빈 화면 표시 (스켈레톤 또는 스피너 필수)
- 빈 상태에 아무 안내 없이 빈 영역만 표시 (아이콘 + 메시지 + CTA 필수)
- H4 이하 제목 사용 (정보 계층 3단계 이내로 구조화)
- 프로세스 디자이너에서 하드 잠금 구현 (소프트 잠금만 허용)

---

## 필수 (Required)

- 모든 사용자 행동에 피드백 제공 (성공/실패/로딩 중 하나)
- 파괴적 작업(삭제/반려)에 AlertDialog 확인 단계
- 모든 목록/테이블에 빈 상태(Empty State) 디자인 포함
- 필터/정렬/페이지 상태의 URL search params 동기화
- @dnd-kit 사용 시 키보드 DnD 접근성 구현
- 프로세스 디자이너 노드 100개 이상 시 뷰포트 컬링 적용
- 모든 차트에 다크 모드 대응 (CSS 변수 참조)
- HITL 흐름에 AI 생성물과 인간 수정본 구분 표시
- 스켈레톤은 실제 콘텐츠 레이아웃을 반영한 형태로 구현

---

## 관련 문서

| 문서 | 관계 |
|------|------|
| `04_frontend/watch-alerts.md` | Watch 알림 UI — Notification Center(§7), 심각도별 토스트 규칙(§9.4) |
| `04_frontend/implementation-guide.md` | 구현 가이드 — Toast, WebSocket, SSE 패턴 코드 예시 |

---

## 변경 이력

| 날짜 | 버전 | 작성자 | 내용 |
|------|------|--------|------|
| 2026-02-20 | 1.1 | Axiom Team | 실시간 알림(Watch Alert) 토스트 규칙 추가 (§2.3), 관련 문서 테이블 추가 |
| 2026-02-20 | 1.0 | Axiom Team | 초기 작성 |
